Následující kapitola popisuje návrh nástroje pro administraci souborového systému ZFS.
\section{Požadavky}
Na začátku bychom si měli stanovit funkcionalitu, kterou budeme po apliakci vyžadovat. Ještě jednou připomenu, že hlavním cílem je vytvořit graficky orientovaný administrátorský nástroj pro správu souborového systému ZFS.

Souborový systém ZFS byl původně integrován v operačním systému Solaris. I přes to, že dnes již existují operační systémy na, které bylo ZFS přeneseno, hlavní platformou aplikace bude právě operační systém Solaris.

Jelikož má nástroj být grafického charakteru, můžeme brát jako první požadavek na aplikaci přítomnost uživatelského rozhraní. O tom jáké druhy uživatelského rozhraní přiapdají v úvahu si povíme hned v následující kapitole.

Jak jsem se již zmínil v úvodu, účelem toho nástroje má být ulehčení a zpřehlednění práce administrátora při správě souborového systému ZFS a to i pro začínajícího administrátora.  Bylo by tedy vhodné, aby zvolené uživatelské rozhraní bylo přehledné a jednoduché na používání. Dalším ulehčením pro administrátora by bylo zajisté vzdálené ovládání tohoto nástroje.

Na konci předchozí kapitoly jsme se dozvěděli, že většina nástrojů využívá takový způsob sběru dat, který uživateli v některých situací znemožňuje vidět přímo aktuílní data. Tohoto problému bychom se při návrhu měli vyvarovat a zvolit takový způsob, který by uživateli aktuální data při každém jeho požadavku zobrazil.

Další nedostatek, který jsme objevli při analýze již vytvořených nástrojů pro správu ZFS, je ten, že většina těchto nástrojů vůbec neposkytuje funkce pro administraci. Dovolují nám tedy danný souborový systém sledovat, ale né ho ovlivňovat, vytvářet nebo nastavovat jeho vlastnosti. Jelikož je ZFS rozsáhlý souborový systém, obsahuje i velké množství funkcí a příkazů, které ho administrují. Bylo by tedy dobré některé základní funkce a příkazy pro administraci ZFS do tohoto nástroje zahrnout.

Posledním bodem požadavků by měla být bezpečnost. Hlavním důvodem proč se starat o bezpečnost apliakace je fakt, že pomocí ZFS lze jednoduchým příkazem zničit vše co se na disku nachází. Jelikož se z disku načítá při startu i operační systém, mohli by následky být fatální. Příklad jak se před tímto problémem chránit si můžeme vzít z Unixových operčních systémů. Na těchto systémech existuje uzivatel \emph{root}, který v systému může dělat uplně vše a poté obyčejní uživatelé, kteří nebezpečné příkazy vykonávat nemohou. To nás může přivést na myšlenku, že aplikace bude přístupná pouze specifikovaným uživatelům.

Pro shrnutí můžeme požadavky na administrátorský nástroj shrnout do následujících bodu.
\begin{itemize}
    \item Solaris
    \item Uživatelské rozhraní
    \item Jednoduchost a přehlednost
    \item Vzdálený přístup
    \item Aktualita dat
    \item Základní funkce pro administraci
    \item Bezpečnost

Splnění těchto požadavků by mělo vést k výsledku, který bychom od administrátorského nástroje mohli očekávat.
\end{itemize}
\section{Možnosti uživatelských rozhraní}
Při návrhu se naskytli následující možnosti pro volbu uživatelského rozhraní.
    \subsection{Příkazová řádka}
    Každý uživatel, který se někdy nějakým způsobem setkal s administrací unixových operačních systémemů by měl mít alespoň nějaké povědomí o tom co je to příkazová řádka. Příkazová řádka je v unixu nástroj, který zkušení administrátoři využívají snad nejraději. Je rychlá, jednoduchá a jediné co potřebujete vědět je, jaký příkaz napsat a co danný příkaz udělá. Vše se obejde bez myši a kdejakého klikání.

    Na druhou stranu pro začínajícího uživatele může být složité si všechny příkazy pamatovat a nějakou dobu trvá než s tímto nástrojem uživatel získá potřebné zkušenosti. Pokud uživatel příkazy příliš neovládá je to pro něj spíše zpomalení práce než zrychlení.

    Protože jsme si v požadavcích stanovali, že náš nástroj má být jednoduchý, přehledný, uživatelsky příjemný na používání i pro začínající uživatele, je tato volba nevhodná.
    \subsection{Grafické rozhraní}
    Jelikož jsme zavrhli příkazovou řádku, je třeba přijít s něčím co bude pro uživatele přívětivé. Každý z vás se již jistě setkal s pojmem grafické rozhraní. Pokud ne, pod pojmem grafické rozhraní si můžete představit například kalkulačku z opearačního systému Windows. Prakticky všechno v operačním systému Windows má svoje grafické rozhraní.

    Jestliže jsme vyřešili problém s uživatelským komfortem pak nám zbývá zvážit možnost vzdáleného přístupu. Ano i v tomto případě bychom byli schopni tento požadavek splnit. Jde o to jak by to pro nás bylo pohodlné. Pokaždé kdybychom chtěli ZFS administrovat, museli bychom mít dotyčnou aplikaci nainstalovanou. Netvrdím, že je to nepřekonatelný problém, ale existuje ještě jedno komfortnější a dnes stále populárnější řešení.
    \subsection{Webové rozhraní}
    Poslední možností je použití webového rozhraní. Hlavní výhodou toho řešení je fakt, že pro přístup k aplikaci potřebujete jen webový prohlížeč. Ten je dnes přítomný v drtivé většině operační systémů. Tato skutečnost nám přináší možnost přistupovat k aplikaci z webového prohlížeče v libovolném operačním systému k aplikaci, která poběží na operačním systému Solaris.

    Webové stránky jsou navíc známé většině uživatelům a tak by při správném návrhu stránek neměl být sebemenší problém s jednoduchostí a přehledností tohoto nástroje.

    Zbytek požadavků jako je bezpečnost jednoduše splníme pomocí správné implementace tohoto řešení.
\section{Architektura aplikace}
V předchozí kapitole jsme pro náš nástroj zvolili možnost zobrazování dat pomocí webového rozhraní. Toto rozhraní se bude skládat z webových stránek, které budeme chtít uživateli zobrazovat. Pro tento účel si budeme muset zvolit nebo implementovat nějaký webový server, který bude zprostředkovávát komunikaci mezi naší aplikací a klientským webovým prohlížečem. Jakmile uživatel požádá pomocí svého webového prohlížeče o nějakou stránku, webový server obdrží tento požadavek a předá ho naší aplikaci. Aplikace tento požadavek vyhodnotí a prostřednictvím webového serveru pošle uživateli odpovídající data.

Náš nástroj má sloužit pro správu souborového systému ZFS a tak bute nutné vymyslet, jak bude naše aplikace s tímto systémem komiunikovat. Aministrátor může ZFS spravovat pomocí příkazů, které jednoduše zadá do příkazové řádky. Tyto příkazy dokáží změnit vnitřní stav souborového systému, nastavit nějakou hodnotu popřípadě vyvolat nějakou akci. Jelikož jsme stanovili, že náš nástroj bude umět využívat základních funkcí ZFS, bude nutné vymyslet vrstvu aplikace, která bude tyto příkazy sestavovat a následně provádět. Na obrázku \ref{architecture} můžeme vidět graficky znázorněnou komunikaci mezi jednotlivými komponenty aplikace.
\begin{figure}[h]
        \caption{Struktura aplikace}
        \label{architecture}
\end{figure}
    \subsection{Architektura MVC}
    Komponenty a komunikaci mezi nimy již rozebrali výše. Nyní je na čase navrhnout řešení, jak bude aplikace fungovat unvnitř. Jak již bylo zmíněno, náš nástroj bude umožňovat správu souborového systému ZFS pomocí jeho základních funkcí. Tudíž né všechny funkce budou ve výsledné implementaci zahrnuty. Z tohoto důvodu je aplikaci nutno navrhnout tak, aby se dala jednoduše rozšiřovat o potřebnou funkcionalitu.

    K tomuto účelu jsem se rozhodl použít objektový návrh společně s architekturou MVC. Model-view-controller (MVC) je softwarová architektura, která rozděluje datový model aplikace, uživatelské rozhraní a řídící logiku do tří nezávislých komponent tak, že modifikace některé z nich má jen minimální vliv na ostatní.<CITATE Wiki-mvc> Pokud bychom chtěli naši aplikaci rozšířit a novou fukncionalitu, jednoduše stačí rozšířit vrstvu, která zajišťuje komunikaci se souborovým systémem. Nově přidané funkce pak můžeme ihned využít ve vyšších vrstvách aplikace.

    Komponenty jednotlivých vrstev aplikace rozdělujeme na \emph{model}, \emph{view} a \emph{controller}.

        \subsubsection{Datová vrstva}
        \verb|Model| je označení pro třídu, která je součástí datové vrstvy aplikace. Úkol této třídy, potažmo i celé datové vrstvy, je manipulace a práce s daty. Jako příklad si můžeme vzít třídu, která má na starost práci s databází. Tato třída obdrží od vyšší vrstvy data a je požádána aby s nimi provedla určitou akci. V databázi může například vytvořit nový záznam popřípadě nějaký modifikovat. V našem případě žádnou databázi potřebovat nebudeme. Všechny datové struktury si totiž ZFS spravuje samo a my k nim nemáme přímý přístup. Naše datová vrstva a její třídy nám tedy budou zajišťovat vykonávání příkazů, které budou sestaveny na základě dat předaných z logické vrstvy. Vykonávat se budou příkazy, které ZFS nabízí jako rozhraní pro jeho správu.
        \subsubsection{Prezentační vrstva}
        Další vrstvou aplikace je tzv. prezentační vrstva. Tato vrstva se skládá z tříd nesoucí obecný název \verb|View|. Dále tato vrstva také zajišťuje vykreslování dat z datové vrsty uživateli. V grafických aplikacích jsou jednotlivé třídy přímo zodpovědné za vykreslování určitých částí výsledného uživatelského rozhraní. V našem případě aplikace poběží na serveru a uživatel se k aplikaci bude připojovat pomocí webového prohlížeče. Ať už ze vzdáleneho nebo lokálního počítače. Nicméně prezentační vrstva nebude přímo vykreslovat uživatelské rozhraní protože neví kam. Pro zachování nezávislosti jednotlivích vrstev, bude prezentační vrstva pouze generovat HTML kód stránky z dat, které jí budou předány. Následně takto vygenerovanou stránku předá zpět do logické vrstvy, která zařídí odeslání stránky uživateli.
        \subsubsection{Logická vrstva}
        Poslední vrstvou aplikace je logická vrstva, někdy také nezývaná bussines vrstva. Hlavním úkolem této vrstvy, je řízení toku dat mezi datovou a prezentační vrstvou. V okamžiku, kdy webový server obdrží nějaký požadavek od uživatele, aplikace vybere z logické vrstvy třídu, která dokáže tento požadavek vyřídit. Tato třída, kterou obecně nazíváme \verb|Controller|, může požádát datovou vrstvu, aby provedla potřebné operace se souborovým systémem nebo od souborového systému získala potřebná data. Následně data převede do potřebného formátu a požádá prezentační vrstvu o jejich vykreslení. V našem případě vykreslená data opět převezme a předá aplikaci, aby je mohla odeslat klientovi.

        Kooperace a komunikace tříd jednotlivích vrstev navrhované aplikace je znázorněna a popsána na obrázku \ref{mvc}.

    \begin{figure}[h]
        \caption{Princip MVC architektury}
        \label{mvc}
    \end{figure}
\section{Interakce s aplikací}
K aplikaci bude administrátor moci přistupovat pomocí jakéhokoli webového prohlížeče. Tato výhoda pramení ze způsobu přenosu webových stránek pomocí protokolu HTTP, který je pro tento účel určený. Jeho definici můžeme najít v RFC dokumentu <CITATE HTTP RFC>. V dnešní době je to jeden z nejpoužívanější protokolů a to zejména proto, že se používá i v internetu. Tento protokol je postavený na architektuře klient-server, kdy klient posílá požadavky na webový server a ten klientovi odpovídá v podobě HTML stránky. Jak jsem již zmiňoval, výhodou tohoto způsobu je oddělenost serveru a klienta. Webový prohlížeč tak klidně může uživatel spouštět na operačním systému Windows nebo Linux zatímco celá aplikace s webovým servervem poběží pod operačním systémem Solaris.

Uživatel tedy bude pomocí webového prohlížeče vznášet požadavky na webový server v podobě URL. Uniform resource locator (URL) se používá pro lokalizování zdrojů na internetu poskytnutím jedinečného řetězce znaků. Jeho definici opět můžeme najív v <CITATE URL RFC>. HTTP požadavek, který administrátor bude pomocí webového prohlížeče odesílat, obsahuje právě tento URL retězec. Tím administrátor specifikuje jakou stránku chce zobrazit popřípadě jakou akci chce povést.

Naši aplikaci tedy postavíme tak, aby byla schopná přijmout URL retězec a na základě jeho struktury provedla určitou akci. První část aplikace bude webovéhý serveru, který bude aplikaci zprostředkovávat požadavky. Dále webový server bude zajišťovat odeslání odpovědi na tyto požadavky. Druhou částí bude zpracování požadavku, provedení akce se souborovým systémem a následné odeslání odpovědi prostřednictvím webového serveru.
\section{Bezpečnost}
Další důležitou kapitolou v procesu návrhu administrátorského nástroje je bezpečnost.

Některé příkazy poskytované souborovým systém ZFS jsou dostupné každému užtivateli v systému. Jedná se hlavně o příkazy, které vypisují nejrůznější informace o stavu souborových systémů a poolů. Prováděním těchto příkazů se v nastavení ZFS nic nemění ani nenastavuje, tudíž nemůže dojít k žádné ztrátě nebo poškození dat. Na druhou stranu ZFS nabízí i příkazy, kteřé běžní uživatelé nemohou využívat. K provádění těchto příkazů je potřeba oprávnění root uživatele. V tomto případě se jedná zejména o příkazy, které vytvářejí, mění nebo ničí souborové systémy či pooly. Toto chování je naprosto pochopitelné, protože nesprávným nebo neuváženým použitím těchto příkazů může dojít ke zničení celého operačního systému popřípadě cenných dat.

Našim cílem je vytvořit nástroj pro správu souborového systému ZFS. Je tedy zřejmé, že budeme potřebovat aby naše aplikace dokázala využívat i příkazy, které nejsou běžným uživatelům dostupné. V operačním systému Solaris, kde naše aplikace poběží, dostává kadžy spuštěný proces takzvanou identitu. Tato identita spojuje běžící proces spolu s uživatelem pod kterým byl proces spuštěn. Díky tomu je operační systém schopen určit, jaká práva proces má a co vše může v systému využívat. Tyto práva přesně odpovídají právům, které má danný uživatel k dispozici. Pokud bychom tedy spustili naší aplikaci pod uživatelem, který nemá právo využívat některé příkazy souborového systému ZFS, pak by ani náš nástroj nemohl tyto příkazy využívat. Tato situace nás tedy vede k tomu abychom naší aplikaci pouštěli pod uživatelem, který má právo vykonávat všechny příkazy, které ZFS poskytuje.

Právě jsme vyřešili problém jak zajistit naší aplikaci potřebná práva pro vykonávání ZFS příkazů. Máme tedy aplikaci, která může v systému provádět potřebné příkazy a je dostupná na nějaké URL. Problém přístupu neoprávněných uživatelů k nebezpečným příkazům byl vyřešen na úrovni systému. Neoprávnění uživatelé jednoduše nemohli nebezpečné příkazy souštět. Nyní jsme ale aplikaci pustili pod uživatelem,který tato práva vlastní a navíc má tato aplikace webové rozhraní dostupné na stanové URL. Každý kdo tuto URL zná, může v tuto chvíli pomocí webového prohlížeče k aplikaci přistoupit a nebezpečné příkazy provádět. To není uplně ideální případ. My bychom chtěli aby k aplikaci mohli přistupovat jenom oprvánění uživatelé pomocí přihlašovacího jména a hesla. K tomuto účelu se výborně hodí vlastnost HTTP protokolu Basic Authentication \ref{httpauth}.

Aplikace je nyní přístupná jen pro oprávněné uživatele, kteří se authentizují pomoci HTTP Basci Authetication. To s sebou přináší další starosti, protože uživatelské jméno a heslo musíme ověřit. Tyto citlivé informace pomocí HTTP protokolu putují přes počítačovou síť až ke koncovému webovému serveru. Podle specifikace <CITATE RFC HTTP>HTTP protokol neumožňuje šifrování. To znamená, že potencionální útočník může na síti odposlechnout požadavek, který obsahuje uživatelské jméno a heslo. Na základě znalosti authentifikační methody Bascic, která je také specifikováná v normě HTTP protokolu <CITATE RFC HTTP>, pak už útoční jednoduše získá uživatelské jméno a heslo, které bylo použito pro vstup do naší aplikace. Pro naše účely by se hodilo pokud bychom mohli přenášená data šifrovat. Přesně pro tento účel slouží HTTPS \ref{https}, což je v podstatě šifrovaná verze HTTP protokolu.
    \subsection{Systémový uživatel}
    \label{sysuser}
    Z důvodů uvedených výše budeme potřebovat vhodného uživatele, pod kterým budeme tuto aplikaci spouštět. V úvahu přicházejí následující možnosti.
    \begin{itemize}
      \item uživatel root
      \item role (RBAC)
    \end{itemize}

    První možností je zvolit uzivatele \emph{root}. Tento uživatel má právo na všechny operace v systému. Může tedy uživatelům měnit hesla, přidávat a odebírat uživatele a tak dále. Volba tohoto uživatele by sice náš problém vyřešila, ale přinesla by další bezpečnostní rizika. Pokud bychom supustili aplikaci s identitou uživatele root, pak by tato aplikace mohla v systému provádět uplně všechno. To ale my nepotřebujeme. Ná bude stačit pokud aplikace bude moci využívat přesně ty nástroje, které ke svá správné funkčnosti potřebuje. Dalším rizikem je fakt, že by potenciální útočník mohl tyto práva nějakým způsobem využít.

    Druhá možnost, která přichází v úvahu, je použití tzv. RBAC. Jedná se o rozšíření bezpečnostního modelu, které nám umožňuje kontrolovat přístup uživatelů k úkonům, které jsou normálně povoleny pouze pro superuživatele \emph{root}. V nerozšířeném bezpečnostním modelu jste buď uživatelem s omezenými možnosti a nebo jste superuživatel a můžete všechno.
    Ve zkratce RBAC umožnuje vytváření tzv. rolí, které se chovají téměř jako normální uživatel. Rozdíl je v tom, že na roli se nedá přihlásit přímo. Do systému se nejprve musí přihlásit klasický uživatel, které si poté smí přiřadit určitě role. Rolím jsou pak přiřazovány bezpečnostní profily, které obsahují jednotlivá privilegia.

    Pro bezpečnost našeho nástroje si tedy vytvoříme roli, které přiřadíme potřebná oprávnění pro vykonávání následujících příkazů.
    \begin{itemize}
      \item zfs
      \item zpool
      \item format
      \item fdisk
      \item TODO
    \end{itemize}

    Aplikaci pak budeme spouštět pod touto rolí. Ve výsledku aplikace bude mít veškerá oprávnění pro svoji správnou činnost a bezpečnostní rizika budou minimální.
    \subsection{HTTP Bascic Authentication}
    \label{httpauth}
    Basic Authetication je způsob authentikace uživatelů pomocí portokolu HTTP. Pokud webový server vyžaduje tuto metodu ověření, uživatel je před přístupem k obashu vyžádán o authentizaci pomocí jména a hesla. Jméno a heslo je pak spolu s požadavek odesláno webovému server k ověření.<CITATE AUTH RFC>

    Pro naší aplikaci to znamená, že webový server bude muset umět ověřit uživatele oproti lokální databázy. Pokud se uživatelské jméno a heslo odeslané webový prohlížečem bude shodovat s uživatelskými údaji v lokální databázi, bude uživateli umožněn vstup do nástroje.

    Pro úkázku si můžeme úkázat jak takováto komunikace server a prohlížeče vypadá. V první řadě prohlížeč odešle normální požadavek bez uživatelských údajů. Jakmile server zjistí, že se v požadavku nevyskytuje hlavička \emph{Authorization}, odešle webovému prohlížeči HTTP odpověď s kódem 401 (Unauthorized). Do hlaviček odpovědi server přidá hlavičku \emph{WWW-Authenticate}, kde specifiku jakou metodu authentikace očekává. V našem případě se bude jednat o metodu \emph{Basic}. Prohlížeč nyní již ví, že server vyžaduje authentizaci a vyžádá uživatele o zadání jména a hesla. Uživateslké údaje se pak poskládají do správného formátu ( jméno:heslo ) a zakódují pomocí base64\footnote{Kódování není šifrování. Kódování je způsob jak data upravit pro přenos. Pokud třetí osoba tyto data zízká je z nich schopná rekonstruovat původní data.} kódování. Požadavek je odeslán znovu, ale tentokrát už prohlížeč přidá hlavičku \emph{Authorize}. Obsahem této hlavičky je jméno metody, kterou prohlížeč použil pro authetikaci a samotné zakódované údaje. Server následně požadavek znovu projde a pokusí se ověřit uživatele oproti lokální databázi. Pokud se údaje shodují, uživatel je připuštěn k chráněnému obsahu. Jestli se údaje neshodují je opět odeslána HTTP odpověď s kódem 401 (Unatuhorized).<CITATE AUTH RFC>

    Náš administrační nástroj bude tedy tuto metodu využívat pro účely authentizace uživatelů. Do všech částí aplikace bude umožněn vstup pouze authentizovaným uživatelů.

    \subsection{HTTPS}
    \label{https}
    Jak jsem již dříve zmiňoval HTTP protokol neumožňuje nijak šifrovat data, která jsou přenášena. Jelikož jsou po síti přenášena citlivá data jako je uživatelské jméno a heslo, musíme šifrování tohoto přenosu zajistit. HTTPS je protokol, který nám přesně tohle nabízí. Tento protokol ve svém základu využívá ke komunikaci HTTP protokol, ale rozdíl oproti klasickému HTTP je v tom, že přenášená data jsou šifrována pomocí SSL nebo TSL.

    V první fázi spojení probíhá takzvaný handshake. V první části tohoto procesu dochází k výměně zpráv a dohodnutí se na šifrovacím algoritmu. Dále si vymění nezbytné kryptografické parametry. Následně si vymění své certifikáty aby se vzájemně mohli identifikovat.<CITATE TSL Handshake> Pokud handshake proběhne v pořádku, klient může začít posílat první požadavek stejně jako pomocí HTTP protokolu.

    Použití protokolu HTTPS zajistí naší aplikaci, že bude pro útočníka téměř nemožné získat uživateslké údaje, které byli použity pro vstup do aplikace.
    \subsection{Shrnutí}
    Pro shrnutí ještě jednou zopakuji jaké bezpečnostní opatření budou provedeny pro zajištění aplikace. Vytvoříme systémovou roli pomocí RBAC, která bude mít privilegia k vykonávání potřebných operací. Výsledná aplikace bude spouštěna pod touto rolí. K autentizaci uživatelů, kteří budou přistupovat k aplikaci, použijeme metodu \emph{Basic} protokolu HTTP. Uživatele budeme ověřovat proti lokální databázi uživatelů. A konečně celý přenos dat mezi webovým serverem a klientem zašifrujeme pomocí protokolu HTTPS.

\section{Integrace do systému}
Pro ulehčení správy celé aplikace ji zaregistrujeme v operačním systému jako službu. Docílíme tím toho, že se operační systém bude sám starat o zapínání, vypínání a restarování celé aplikace. Samozřejmě, že budeme stále schopni explicitně říct jestli má danná aplikace běžet nebo ne.

Service Management Facility (SMF) je v operačním systému Solaris nástroj pro spravování služeb. Nahrazuje tím tradiční způsob spravování služeb pomocí \emph{init} scriptů, který byl běžný v dřívějších verzí opearčního systému Solaris a ostatní unixových operačních systémů. Velkou výhodou SMF je možnost definování zavislostí danné služby na ostatní službách. Tím dokážeme stanovit, že se danná služba nespustí dokud nebudou spuštěny všechny služby stanovené v závislostech. SMF uchovává veškeré informace o startu, běhu i ukončování služby v logu. Administrátor má tedy kdykoli možnost tyto logy prozkoumat a získat požadované informace. V pozadí každé služby zaregistrované v SMF je takzvaný manifest. <CITATE SMF>
    \subsection{Manifest}
    Manifest je XML dokument, který dannou službu popisuje. Právě zde administrátor stanovuje, na kterých službách bude tato služba závislá nebo jak se danná služba jmenuje. V našem případě to znamená, že si budeme muset tento manifest vytvořit a zaregistrovat službu v SMF. Administrátor pak bude schopen službu spravovat pomocí jednoduchých příkazů.
    \subsection{Metody}
    Důležitou součástí manifestu jsou metody, které SMF říkají, jak má dannou službu zaponout nebo vypnout. V těchto metodách se může spouštět více procesů, které jsou svázány dohromady jako součást danné služby. Administrátor se pak stará jenom o službu jako takovou a nemusí vůbec vědět jaké procesy byli v rámci služby spuštěny.<CITATE SMF> Mimo jiné můžeme v manifestu určit takzvaný kontext metod. Tato vlastnost nám dovoluje určit pod jakým uživatelem mají být jednotlivé metody vykonávány. V kontextu naší aplikace to znamená, že metody služby budou spouštěny pod námi vytvořenou rolí, která bude mít dostatečná práva.
    \subsection{Shrnutí}
    Zaregistrování aplikace jako služby v operačním systému Solaris nám přinese následující výhody ve správě této aplikace. Administrátor bude mít jasný přehled na tím zda danná služba běží nebo neběží. Dále bude moci jednoduše dannou službu spustit popřípadě zastavit. Pokud dojde k nějakému problému při spuštění danné služby, SMF administrátorovi poskytne informace o zdroji tohoto problému. V poslední řadě SMF také umožňí automatické spuštění služby při startu systému.
    

